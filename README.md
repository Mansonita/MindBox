
## Задание 1

Задачу можно было реализовать несколькими способами. Я выбрала самый простой и лёгкий в поддержании.

Способ 1) Паттерн Стратегия. В фигуру можно было бы передавать стратегию для расчёта площади, например, создать функцию/делегат double CircleAreaCalculator(Circle circle) и внедрить её через конструктор new Circle(5, CircleAreaCalculator). Но я решила не применять этот паттерн по нескольким причинам:

1. Формулы расчёта площади у фигур никогда не изменяются.
2. Геометрические фигуры чрезвычайно редко имеют одинаковые формулы расчёта. Квадрат и прямоугольник — ещё не причина применять этот паттерн.
3. Нет смысла отделять логику расчёта площади от самой фигуры, это не пригодится даже в тестировании.
4. Внедрение стратегии через конструктор усложняет API класса, и скорее всего потребует ещё и применения паттерна Factory с private/internal конструкторами фигур. Вывод — не пойдёт.

Способ 2) Паттерн Визитор. С его помощью тоже можно было бы реализовать задачу, но в общем он предназначен для других задач. Реализовывать этот паттерн при наличии всего одной visitor функции не оправдывает сильного усложнения кода. Вывод — не пойдёт.

Способ 3) Использование интерфейсов. Почему интерфейсы, а не базовый класс? В общем, пока нет причин для использования базового класса, а интерфейсы предоставляют более удобный и несвязанный уровень абстракции. Базовый класс можно добавить при необходимости, но клиентам библиотеки об этом знать и не нужно. Вывод — пойдёт!

## Задание 2
```
SELECT p.ProductName, c.CategoryName
FROM Products p
LEFT JOIN ProductCategories pc ON p.ProductID = pc.ProductID
LEFT JOIN Categories c ON pc.CategoryID = c.CategoryID
```
